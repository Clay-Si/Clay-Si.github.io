<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="生活，技术，投资，阅读" />
   
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Clay&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Clay-Si/Clay-Si.github.io"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Clay&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['人生的高度，一半始于努力，一半源于选择', '人所能获得的最大的幸运，唯有自身的个性', '过去事，过去心，不可记得；现在事，现在心，随缘即可；未来事，未来心，何必劳心'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-初识串"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/13/%E5%88%9D%E8%AF%86%E4%B8%B2/"
    >初识串</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/13/%E5%88%9D%E8%AF%86%E4%B8%B2/" class="article-date">
  <time datetime="2020-10-13T11:58:03.000Z" itemprop="datePublished">2020-10-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>&emsp;&emsp;串(string)是由零个或者多个字符组成的有限序列，又名叫字符串。一般记为s = “a<sub>1</sub>…a<sub>n</sub>“(n&gt;=0)。双引号括起来，n为串的长度。</p>
<h5 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h5><p>&emsp;&emsp;实际上串的比较是通过字符的编码来进行的，常用的就是ASCII编码，例如比较”silly”和”stupid”，第一个都是s，没有大小差异，第二个是”i”和”t”，i为105，t为116，i在前，所以”silly”&lt;”stupid”。</p>
<h5 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">    串中元素仅有一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    StrAssign(T, *chars) 生成一个值为空字符串常量的串T</span><br><span class="line">    StrCopy(T,S) 串S存在，复制得T</span><br><span class="line">    ClearString(S) 串清空</span><br><span class="line">    StrLength(S) 串长度</span><br><span class="line">    StringEmpty(S) 判空</span><br><span class="line">    StrCompare(S,T) S&gt;T，返回值&gt;<span class="number">0</span>，S=T，返回值=<span class="number">0</span>，否则返回值&lt;<span class="number">0</span></span><br><span class="line">    Concat(T,S1,S2) 用T返回S1、S2联接的新串</span><br><span class="line">    SubString(Sub,S,pos,len) 串S存在，<span class="number">1</span>&lt;=pos&lt;=StrLength(S),且<span class="number">0</span>&lt;=len&lt;=StrLength(S)-pos+<span class="number">1</span>,用Sub返回串S第pos个字符起长度为len的子串</span><br><span class="line">    Index(S,T,pos) </span><br><span class="line">    串S和T存在，T非空，<span class="number">1</span>&lt;=pos&lt;=StrLength(S),若S中存在和T相同的子串，返回它在S中第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span>    </span><br><span class="line">    Replace(S,T,V) S、T、V存在，T非空，用V替换S中出现的所有与T相等的不重叠的子串。</span><br><span class="line">    StrInsert(S,pos,T) S和T存在，<span class="number">1</span>&lt;=pos&lt;=StrLength(S)+<span class="number">1</span>,在串的第pos个字符之前插入串T</span><br><span class="line">    StrDelete(S,pos,len) S存在，<span class="number">1</span>&lt;=pos&lt;=StrLength(S)-len+<span class="number">1</span>,从S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<p>Index的算法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,i;</span><br><span class="line">    <span class="keyword">String</span> sub;</span><br><span class="line">    <span class="keyword">if</span> (pos&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = StrLength(S);</span><br><span class="line">        m = StrLength(T);</span><br><span class="line">        i = pos;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SubString(sub,S,i,m);<span class="comment">//取串S第i个位置长度与T相等的子串给sub</span></span><br><span class="line">            <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h5><h6 id="串的顺序存储"><a href="#串的顺序存储" class="headerlink" title="串的顺序存储"></a>串的顺序存储</h6><p>&emsp;&emsp;穿的顺序存储结构是用一组地址连续的存储单元来存储传中的字符序列的。按照预定义的大小，为每个串变量分配一个固定长度的存储区，一般是定长数组。可以将串长度存在下表为0的位置，也可以是最后一个位置，或者是”\0”结尾表示串的终结，但是这样只有遍历了才知道串长。</p>
<h6 id="串的链式存储"><a href="#串的链式存储" class="headerlink" title="串的链式存储"></a>串的链式存储</h6><p>&emsp;&emsp;串中的每个数据元素是一个字符，一个结点对应一个字符，比较浪费空间，因此可以一个结点存放多个字符，最后一个结点未被占满，用其他非串值字符补全，例如”#”。<strong>此处应有图</strong>，具体一个结点存多少个字符，这将直接影响串处理的效率，根据实际情况而定。链式存储除了连接串操作方便，它不如顺序存储灵活，性能也不如顺序存储好。</p>
<h5 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h5><p>&emsp;&emsp;子串的定位操作通常称作串的模式匹配(最重要的操作之一)。</p>
<p>假设从主串S=”goodgoogle”中，找到T=”google”子串的位置，通常是以主串的每一个字符为子串开头，与要匹配的字符串进行匹配，直到匹配成功。只用基本的数组来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S,<span class="keyword">String</span> T,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos; <span class="comment">//主串中当前位置下标，若pos不为1，从pos位置匹配。</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">//用于子串T中当前位置下标</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=T[<span class="number">0</span>])<span class="comment">//i小于S长度，j小于T的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>; <span class="comment">//i退后到上次匹配首位的下一位</span></span><br><span class="line">            j = <span class="number">1</span>; <span class="comment">//j回到T的首位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h5><p>&emsp;&emsp;如果主串S=”abcdefgab”，匹配T =”abcdex”，如果用在正常的循环，必须到第六位才知道不匹配，而后又要从S的第二位为头与T比较，如此比下去，其实是在重复工作。第一次比较可知，T的前五位不相等，并且与S的前五位一一对应相等，那么久不需要再用T的第一位与S的二到五位进行比较。KMP模式匹配算法就是为了不进行没必要的回溯。</p>
<p>例子</p>
<p>S = “abcababca”，T = “abcabx”</p>
<p><img src="https://pic.downk.cc/item/5f8595ad1cd1bbb86bc6b844.png" alt=""></p>
<p><img src="https://pic.downk.cc/item/5f8595ad1cd1bbb86bc6b847.png" alt=""></p>
<p>&emsp;&emsp;S的前五位和T的前五位对应相等，且T的前三位都不相等，不需要再与S二三位开头的子串分别判断。T的首位a与T的第四位a相等，第二位b与第五位b相等，在第一步中，第四位的a和第五位的b就与S的对应位置比较过，相等因此不需要再判断。在子串中有与首字符相等的字符。可以省略一部分判断。S下标i不进行回溯，T的下标j的变化，j值的多少取决于当前字符之前的串的前后缀的相似程度。</p>
<h6 id="next数组的推导"><a href="#next数组的推导" class="headerlink" title="next数组的推导"></a>next数组的推导</h6><p>&emsp;&emsp;T = “abcabx”， j=1,next[1]=0, j=2,next[2]=1 , j = 3,next[3]=1,  j=4, next[4]=1,  j = 5,此时j由1到j-1的串是abca，前缀a与后缀a相等，因此next[5]=2, j=6, j由1到j-1的串是abcab，前缀ab与后缀ab相等，next[6]=3。因此next[j] = {0,1,1,1,2,3}</p>
<p>若前后缀n个字符相等，就为n+1。</p>
<h6 id="KMP模式匹配的算法实现"><a href="#KMP模式匹配的算法实现" class="headerlink" title="KMP模式匹配的算法实现"></a>KMP模式匹配的算法实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算返回子串T的next数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T[i] == T[j]) <span class="comment">//T[i]表示后缀的单个字符，T[j]表示前缀的单个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];<span class="comment">//若字符不相同，则j值回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">255</span>];</span><br><span class="line">    get_next(T, next);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> ||S[i]==T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与朴素模式匹配算法相比，i值不回溯，效率提高了。获取next数组时间复杂度为O(n)，while循环的时间复杂度为O(m)。整个时间复杂度为O(n+m)。</p>
<h6 id="KMP模式匹配算法改进"><a href="#KMP模式匹配算法改进" class="headerlink" title="KMP模式匹配算法改进"></a>KMP模式匹配算法改进</h6><p>&emsp;&emsp;对于S=”aaaabcde”，T= “aaaaax”,next数组为012345，但是开始时，i=5、j=5时，该位置a与对应b不相等。因为T中的第二三四五位置上的字符都与首位a相等，那么可以用首位的next[1]取代与它相等的字符后续的next[j]的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T[i] == T[j]) <span class="comment">//T[i]表示后缀的单个字符，T[j]表示前缀的单个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(T[i]!=T[j]) </span><br><span class="line">                <span class="comment">/*若当前字符与前缀字符不同，</span></span><br><span class="line"><span class="comment">                则当前的j为nextval在i位置的值</span></span><br><span class="line"><span class="comment">            	*/</span></span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">            <span class="comment">/*如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位			置的值*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = nextval[j];<span class="comment">//若字符不相同，则j值回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="nextval数组的推导"><a href="#nextval数组的推导" class="headerlink" title="nextval数组的推导"></a>nextval数组的推导</h6><p>T = “aaaaaaaab” ,next[j]={0,1,2,3,4,5,6,7,8}</p>
<ol>
<li>j=1, nextval[1]=0;</li>
<li>j=2, next = 1, 第二个字符与第一个字符相等，所以nextval[2] = nextval[1]=0，<strong>如果不相等，维持next原值。</strong></li>
<li>j=3, 第三个字符与第二个字符相等，所以nextval[3] = nextval[2]=2。</li>
<li>同理………..</li>
<li>当j=9时，next值为8，但是第九个字符与第八个不相等，所以nextval[9]=8。</li>
</ol>
<p>&emsp;&emsp;改进的KMP算法，它是在计算出next值的同时，如果a位字符与它next指向的b位字符相等，则该a位的nextval就指向b位的nextval的值，如果不等，则a位的nextval值就是ta的next值。</p>
<p><strong>注：内容来自《大话数据结构》，图片由Visio2016绘画后截图所得。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-栈与队列初识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%88%9D%E8%AF%86/"
    >栈与队列初识</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/09/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2020-10-09T14:05:29.000Z" itemprop="datePublished">2020-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>是限定仅在表尾进行插入和删除操作的线性表。(撤销、后退功能常用结构)</li>
<li>允许插入和删除的一端称为<strong>栈顶，也是表尾</strong>，另一端称为栈底，没有数据元素称为空栈，栈成为<strong>后进先出的线性表</strong>，LIFO结构。</li>
<li>栈元素具有线性关系，即前驱后继关系。</li>
<li>栈的插入操作，叫进栈、压栈、入栈；删除操作，叫出栈、弹栈。</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f806c901cd1bbb86bb0a2f4.png" alt="栈的操作"></p>
<h5 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(Stack)</span><br><span class="line"><span class="comment">// 理论上线性表的操作特性它都具备</span></span><br><span class="line">Data</span><br><span class="line">    同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    InitStack(*S)  建立一个空栈</span><br><span class="line">    DestroyStack(*S) 若栈存在，销毁它</span><br><span class="line">    ClearStack(*S) 清空栈</span><br><span class="line">    StackEmpty(S) 栈为空，返回<span class="literal">true</span>，否则<span class="literal">false</span></span><br><span class="line">    GetTop(S, *e) 若栈存在且非空，用e返回S的栈顶元素</span><br><span class="line">    Push(*S, e) S存在，插入新元素e到栈S中，为栈顶元素</span><br><span class="line">    Pop(*S, *e) 删除栈顶元素，并用e返回值</span><br><span class="line">    StackLength(S) 返回栈S的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h5 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h5><p>&emsp;&emsp;栈的顺序存储是线性表顺序存储的简化——顺序栈。用数组实现，下标为0的一端作为栈底，首元素变化最小，因此作为栈底。</p>
<h6 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType; <span class="comment">//根据实际而定</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.downk.cc/item/5f806d671cd1bbb86bb13669.png" alt="栈的结构"></p>
<h6 id="进栈push"><a href="#进栈push" class="headerlink" title="进栈push"></a>进栈push</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqStack *S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    is(S-&gt;top == MAXSIZE - <span class="number">1</span>)<span class="comment">//判断栈满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    S-&gt;top++; <span class="comment">//栈顶指针加1</span></span><br><span class="line">    S-&gt;data[S-&gt;top] = e; <span class="comment">//将新元素赋值给栈顶空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="出栈pop"><a href="#出栈pop" class="headerlink" title="出栈pop"></a>出栈pop</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    is(S-&gt;top == <span class="number">-1</span>)<span class="comment">//判断栈空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    *e = S-&gt;data[S-&gt;top]; <span class="comment">//将要删除的栈顶元素赋值给e</span></span><br><span class="line">    S-&gt;top--; <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h5><p>&emsp;&emsp;顺序栈存在一个问题，就是必须实现确定数组的存储空间大小，否则扩展容量比较麻烦。为此，两个相同类型的栈可以共享空间。<strong>方法为：</strong> 同一个数组存储两个栈，让一个栈的栈底做数组的始端，下标为0，另一个栈的栈底为数组的末端，下标为n-1(n为数组长度)。即存储时从数组的两端向中间靠拢，两个栈顶指针不碰面，就可以继续使用。</p>
<p><img src="https://pic.downk.cc/item/5f806c901cd1bbb86bb0a2f0.png" alt="两栈共享空间"></p>
<h6 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(SqDoubleStack *S, SElemType e, <span class="keyword">int</span> stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top1 + <span class="number">1</span> == S-&gt;top2) <span class="comment">//栈满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;data[++S-&gt;top1] = e; <span class="comment">//top1+1后赋值新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(stackNumber == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;data[--S-&gt;top2] = e; <span class="comment">//top2-1后赋值新元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(SqDoubleStack *S, SElemType *e, <span class="keyword">int</span> stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top1 == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(stackNumber == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top2 == MAXSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//栈空</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h5><p>栈的链式存储结构，简称链栈。</p>
<p>&emsp;&emsp;单链表有头指针，将栈顶指针和头指针合二为一，将栈顶放在单链表的头部。对于链栈来说，除非内存已经没有可以使用的空间了，否则不存在栈满的情况。</p>
<p><img src="https://pic.downk.cc/item/5f806c901cd1bbb86bb0a301.png" alt="链栈"></p>
<p>链栈的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>

<h6 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack *S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = S-&gt;top; <span class="comment">//将当前栈顶元素赋值给新结点的直接后继</span></span><br><span class="line">    S-&gt;top = s;</span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack *S, SElemType *e)</span></span>&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    p = S-&gt;top;</span><br><span class="line">    S-&gt;top = S-&gt;top-next;<span class="comment">//使得栈顶指针下移一位。</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放结点p</span></span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于顺序栈和链栈，时间复杂度是一样的，都是O(1)；对于空间性能，顺序栈需要事前确定一个定长，存取时定位方便，而链栈要求每个元素都有指针域，增加了内存开销，但是对于栈的长度无限制。对于元素变化不可预料的，最好使用链栈。</p>
<h5 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h5><p>&emsp;&emsp;许多高级语言都对栈结构进行了封装，不用关心实现细节，直接使用push和pop方法即可。</p>
<h5 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h5><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p>&emsp;&emsp;一个函数直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称为递归函数。每个递归定义必须至少有一个条件，满足时递归不再进行。</p>
<p>递归和迭代的区别：</p>
<ul>
<li>迭代使用的是循环结构，不需要反复调用函数和占用额外的内存</li>
<li>递归使用的是选择结构，让程序的结构看起来清晰，但是大量的递归调用会建立函数的副本，消耗大量的时间和内存。</li>
</ul>
<p>&emsp;&emsp;在递归的前行阶段，函数的局部变量、参数值以及返回地址都被压入栈中，在退回阶段，栈顶的局部变量、参数值、返回地址被弹出。</p>
<h6 id="四则运算表达式"><a href="#四则运算表达式" class="headerlink" title="四则运算表达式"></a>四则运算表达式</h6><ol>
<li><p>后缀表示法(逆波兰)</p>
<p>所有的符号都是在运算数字的后面出现。</p>
<p>例如：9+(3-1) * 3+10/2—&gt;9 3 1 - 3 * + 10 2 / +</p>
<p>计算顺序：9、3、1进栈—&gt;1、3出栈3-1=2入栈—&gt;3进栈—&gt;3、2出栈 3 * 2=6进栈—&gt;6、9出栈 6+9=15进栈—&gt;10、2进栈—&gt;2、10出栈10/2=5进栈—&gt;5 、15出栈 5+15=20进栈—&gt;20出栈，栈空。</p>
</li>
<li><p>中缀表达式转后缀表达式</p>
<p>正常用的标准表达式都是中缀表达式</p>
<p>规则：（此时栈用来进出运算的符号）从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，成为后缀表达式的一部分；若是符号，判断其与栈顶符号的优先级，是右括号或者优先级低于栈顶，则栈顶元素依次输出(栈顶在变)，并将当前符号进栈，一直到最终输出的后缀表达式为止。</p>
</li>
</ol>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列</strong>是只允许在一端进行插入操作、另一端进行删除操作的线性表。</p>
<ul>
<li>队列是一种先进先出的线性表，FIFO结构，允许插入的一端是队尾，允许删除的一端是队头。</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f806c901cd1bbb86bb0a2ee.png" alt="队列"></p>
<h5 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line"><span class="comment">// 理论上线性表的操作特性它都具备</span></span><br><span class="line">Data</span><br><span class="line">    同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    InitQueue(*Q)  建立一个空队列</span><br><span class="line">    DestroyQueue(*Q) 若队列存在，销毁它</span><br><span class="line">    ClearQueue(*Q) 清空队列</span><br><span class="line">    QueueEmpty(Q) 队列Q为空，返回<span class="literal">true</span>，否则<span class="literal">false</span></span><br><span class="line">    GetHead(Q, *e) 若队列Q存在且非空，用e返回Q的队头元素</span><br><span class="line">    EnQueue(*Q, e) S存在，插入新元素e到队列Q中，为队尾元素</span><br><span class="line">    DeQueue(*Q, *e) 删除队头元素，并用e返回值</span><br><span class="line">    QueueLength(Q) 返回队列Q的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><h6 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h6><p>&emsp;&emsp;入队操作其实就是在队尾加一个元素，不需要移动任何元素，时间复杂度为O(1)，但是出队操作是在队头，下标为0的位置，其他元素都得向前移动，时间复杂度为O(n)。为了解决这个问题，可以让队头不一定在下标为0的位置。</p>
<p>&emsp;&emsp;为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个元素，当<strong>front=rear</strong>时，为空队列。</p>
<p>&emsp;&emsp;当队头不在0位置，出栈之后不用前移，而追加元素后，rear指针已经越界，此时队头位置为空，队尾已经满，再追加元素，会产生“假溢出现象”。</p>
<p>&emsp;&emsp;<strong>循环队列</strong>就是头尾相接的顺序存储结构。队尾没有空间，rear指针可以指向下标为0的位置。</p>
<p><strong>问题：</strong>rear = front时，队满或者队空，如何判断具体时队满还是队空呢？</p>
<ul>
<li>方法一：设置一个标志变量flag，当front == rear时, 如果flag=0时为队空，如果flag=1时为队满。</li>
<li>方法二：当队空时，条件是rear = front，当队列满时，保留一个元素空间，也就是队列满，数组还有一个空闲单元。</li>
</ul>
<p><img src="https://pic.downk.cc/item/5f806d671cd1bbb86bb13666.png" alt="循环队列"></p>
<p><strong>注意：</strong>rear可能比front大，也可能小，可能rear与front只差一个位置，但是它们相差一圈。若最大尺寸为QueueSize，队满条件应该为<strong>(rear+1)%QueueSize == front。</strong></p>
<p>队列长度：</p>
<ul>
<li>rear&gt;front , 队列长 = rear-front</li>
<li>rear&lt;front , 队列长 = (rear-front+QueueSize)%QueueSize</li>
</ul>
<h6 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">//判断队列满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//rear指针后移一位，若到最后则转向数组头</span></span><br><span class="line">    <span class="comment">//这也是%MAXSIZE的用处</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front) <span class="comment">//判断队空，此时采用方法二区别队列空、满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front = (Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">//front指针后移一位，若到最后则</span></span><br><span class="line">    <span class="comment">//转到数组头部。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h5><p>&emsp;&emsp;队列的链式结构，其实就是线性表的单链表，只不过是尾进头出，简称链队列。为了操作方便，将队头指针指向链队列的头结点，而队尾指针指向终端结点。当队列为空时，front和rear都指向头结点。</p>
<p><img src="https://pic.downk.cc/item/5f806c901cd1bbb86bb0a2fb.png" alt="链队列"></p>
<p>链队列的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QEmleType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> // 结点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElmeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //队列的链表结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front,rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<h6 id="链队列—入队"><a href="#链队列—入队" class="headerlink" title="链队列—入队"></a>链队列—入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="comment">//存出分配失败</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = s; <span class="comment">//新结点s分配给原队尾结点的后继</span></span><br><span class="line">    Q-&gt;rear = s; <span class="comment">//当前的s设置为队尾结点，rear指向s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链队列—出队"><a href="#链队列—出队" class="headerlink" title="链队列—出队"></a>链队列—出队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = Q-&gt;front-&gt;next;   <span class="comment">//将要删除的队头结点暂存在p</span></span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">//将原队头结点后继赋值给头结点后继</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == p) <span class="comment">//若队头时是队尾，删除后将rear指向头结点。</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="循环队列和链队列比较"><a href="#循环队列和链队列比较" class="headerlink" title="循环队列和链队列比较"></a>循环队列和链队列比较</h6><ul>
<li>时间上，两者基本操作都是常数时间，循环队列需要提前申请好空间，使用期间不释放，对于链队列，每次申请和释放存在时间开销。</li>
<li>空间上，循环队列必须要有一个固定长度，所以就有了存储元素个数和空间浪费的问题，而链队列尽管需要一个指针域，会产生开销，但是不存在上述问题。</li>
</ul>
<p><strong>注：内容来自《大话数据结构》，图使用Visio2016绘画后截图所得。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-线性表初识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%9D%E8%AF%86/"
    >线性表初识</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/10/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2020-10-07T09:54:30.000Z" itemprop="datePublished">2020-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="线性表-List"><a href="#线性表-List" class="headerlink" title="线性表(List)"></a>线性表(List)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>&emsp;&emsp;零个或者多个数据元素的<strong>有限序列</strong>。是数据结构中最常用最简单的一种结构。元素是有顺序的，并且是有限个，若有多个元素，第一个元素无前驱，最后一个无后继，其他每个元素都有且只有一个前驱和后继。</p>
<h5 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h5><blockquote>
<p>ADT 线性表(List)</p>
<p>Data</p>
<p>&emsp;&emsp;线性表的数据对象集合为{a<sub>1</sub>,a<sub>2</sub>,……a<sub>n</sub>},每个元素的类型均为DataType。其中除了第一个元素外，每个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是<strong>一对一的关系。</strong>对于不同的应用，线性表的基本操作有不同的，以下是最基本的操作：</p>
<p>Operation</p>
<ul>
<li>InitList(*L) 初始化，建立一个空的线性表L</li>
<li>ListEmpty(L) 若线性表为空，返回true，否则false</li>
<li>ClearList(*L) 将线性表清空</li>
<li>GetElem(L,i,*e) 将线性表L中的第i个为止元素值返回给e</li>
<li>LocateElem(*L,i,e) 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号，否则返回0</li>
<li>ListInsert(*L,i, *e) 在线性表L中的第i个位置插入新元素e</li>
<li>ListDelete(*L,i , *e) 删除线性表L中的第i个位置元素，并用e返回其值</li>
<li>ListLength(L) 返回线性表L的元素个数</li>
</ul>
<p>endADT</p>
</blockquote>
<h5 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h5><p>&emsp;&emsp;线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。在内存中，通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。用C语言的一维数组来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>顺序存储结构的三个属性：</p>
<ul>
<li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li>
<li>纤细你个表的最大存储容量：数组长度为MaxSize。</li>
<li>线性表的当前长度：length。</li>
</ul>
<p>数组长度是存放线性表的存储空间的长度，存储分配后通常是不变的。</p>
<p>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作，这个量是变化的。但线性表的长度是不大于数组长度的。</p>
<h6 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h6><ol>
<li>获取元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="comment">// 1&lt;=i&lt;=L.length</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//获取成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入操作</li>
</ol>
<p>在线性表的第i个位置插入元素e，思路是：</p>
<ul>
<li>如果插入位置不合理，抛出异常；</li>
<li>如果线性表长度大于等于数组长度，抛出异常或者动态增加容量；</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将它们后移一个位置；</li>
<li>将新元素填入位置i处；</li>
<li>表长加1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设线性表L存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == MAXSIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L-&gt;length)<span class="comment">//i位置是否在表尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>] = L-&gt;data[k];<span class="comment">//i位置及以后的元素后移一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>] = e; <span class="comment">//插入新元素</span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除操作</li>
</ol>
<p>删除线性表的第i个位置的元素，思路：</p>
<ul>
<li>删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将他们向前移动一个位置；</li>
<li>表长减1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)<span class="comment">//删除的是否是最后一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i; k&lt;L-&gt;length;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k<span class="number">-1</span>] = L-data[k];<span class="comment">//将删除位置后继元素向前移动一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在插入和删除元素时候，最坏情况就是删除或者插入第一个位置，后续都要移动，时间复杂度为O(n)。</p>
<p>通过位置i，可以直接计算出它在线性表的位置，所以对于储存和读取，时间复杂度是O(1)。</p>
<p>通过对比可知，<strong>线性表适合元素个数变化不太大</strong>，更多的是存取数据的应用。</p>
<h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><ul>
<li>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；可以快速地存取表中任何一个位置的元素。</li>
<li>缺点：插入和删除操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；造成存储空间的“碎片”。</li>
</ul>
<h5 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h5><p>&emsp;&emsp;n个结点链接成一个链表，即为线性表的链式存储结构，每个结点中包含数据域和指针域，指指针域存储直接后继的存储位置。链表的每个结点中只包含一个指针域成为单链表。</p>
<p><img src="https://pic.downk.cc/item/5f7d8ce31cd1bbb86b68baf7.png" alt="链式存储"></p>
<p>&emsp;&emsp;链表中的第一个结点的存储位置叫做头指针，整个链表的存取就必须从头指针开始进行了，最后一个结点没有后继，指针为空。</p>
<p><img src="https://pic.downk.cc/item/5f7d8ce31cd1bbb86b68baea.png" alt="带有头指针"></p>
<p>&emsp;&emsp;有时为了更方便对链表进行操作，会在单链表的第一个结点前附设一个结点，为头结点。头结点的数据域可以不存储任何信息，也可以存储如表长等附加信息。</p>
<p><img src="https://pic.downk.cc/item/5f7d8ce31cd1bbb86b68bae7.png" alt="带头结点"></p>
<h6 id="头指针和头结点"><a href="#头指针和头结点" class="headerlink" title="头指针和头结点"></a>头指针和头结点</h6><ol>
<li>头指针：<ul>
<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</li>
<li>头指针具有标识作用，所以常用头指针冠以链表的名字。</li>
<li>无论链表是否为空，头指针不为空，<strong>头指针是链表的必要元素。</strong></li>
</ul>
</li>
<li>头结点：<ul>
<li>头结点是为了操作的统一和方便设立的，放在第一个元素的结点之前，其数据域一般无意义(或者存放链表的长度)。</li>
<li>有了头结点，对在第一个元素结点前插入结点和删除第一个结点，其操作与其它结点的操作就统一了。</li>
<li><strong>头结点不一定是链表的必须要素。</strong></li>
</ul>
</li>
</ol>
<h6 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的单链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假设p是只想线性表第i个元素的指针，则该结点的数据域表示为p-&gt;data，其值是一个数据元素，结点的指针域用p-&gt;next来表示，其值是一个指针。</p>
<p><img src="https://pic.downk.cc/item/5f7d8f9e1cd1bbb86b6972b0.png" alt="结点与后继"></p>
<h5 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h5><p>思路：从开头开始遍历，直到第i个元素为止，最坏情况时间复杂度为O(n)。</p>
<ol>
<li>声明一个结点p只想链表的第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成功，返回结点p的数据。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表L存在</span></span><br><span class="line"><span class="comment">//获取第i个数据元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-&gt;next;<span class="comment">//p指向L的第一个结点</span></span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;<span class="comment">//p指向下一个结点</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//第i个元素不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h5><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>单链表第i个数据插入结点的算法思路：</p>
<ol>
<li>声明一个结点p指向链表第一个结点，初始化j从1开始；</li>
<li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li>
<li>若到链表末尾p为空，则说明第i个元素不存在；</li>
<li>否则查找成空，在系统中生成一个空结点s；</li>
<li>将数据元素e赋值给s-&gt;data；</li>
<li>单链表的插入标准语句s-&gt;next = p -&gt;next; p-&gt;next = s;</li>
<li>返回成功；</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表存在，在L中第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(LinkList *L,<span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    LinKList p,s;</span><br><span class="line">    p =  *L;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!P || j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p>核心语句：p-&gt;next = p-&gt;next-&gt;next; </p>
<p>用q代替p-next: q = p-&gt;next; p-&gt;next = q-&gt;next; free(q);</p>
<h5 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h5><p>&emsp;&emsp;对于一个链表来说，它所占空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。所以单链表创建过程就是一个动态生成链表的过程，从空表起，依次建立各个元素结点，并逐个插入链表。</p>
<p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机生成n个元素的值，建立带表头结点的单链线性表L(头插法)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>; <span class="comment">//建立一个带头结点的单链表</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//新结点</span></span><br><span class="line">        p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>; <span class="comment">//给新结点随机赋值</span></span><br><span class="line">        p-&gt;next = (*L)-&gt;next;</span><br><span class="line">        (*L)-&gt;next = p; <span class="comment">//插入到表头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上为头插法，尾插法即是将新元素依次插入到链表末尾，最后一个元素指针域设为NULL。</p>
<h5 id="单链表的正标删除"><a href="#单链表的正标删除" class="headerlink" title="单链表的正标删除"></a>单链表的正标删除</h5><p>算法：</p>
<ol>
<li>声明一个结点p和q</li>
<li>将第一个结点赋值给p</li>
<li>循环：<ul>
<li>将下一个结点赋值给q</li>
<li>释放p</li>
<li>将q赋值给p</li>
</ul>
</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClearList</span><span class="params">(LinkList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = (*L)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单链表结构与顺序存储结构的优缺点"><a href="#单链表结构与顺序存储结构的优缺点" class="headerlink" title="单链表结构与顺序存储结构的优缺点"></a>单链表结构与顺序存储结构的优缺点</h5><ol>
<li>存储分配方式：<ul>
<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>
<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>
</ul>
</li>
<li>时间性能：<ul>
<li>查找：顺序存储结构O(1),单链表O(n)</li>
<li>插入删除：顺序存储结构需要平均移动表长一半的元素为O(n), 单链表在算出某位置的指针后，插入删除时间仅为O(1)。</li>
</ul>
</li>
<li>空间性能：<ul>
<li>顺序存储结构需要预先分配存储空间，分大了，浪费，小了容易发生上溢。</li>
<li>单链表不需要分配存储空间，只要有就可以分配。</li>
</ul>
</li>
</ol>
<p>因此，<strong>若频繁查找，可以采用顺序存储结构，若频繁删除和插入，可以采用单链表结构。</strong></p>
<p>当元素个数未知或者变化较大时，可以采用单链表结构。</p>
<h5 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h5><p>&emsp;&emsp;让数组的元素都由两个数据域组成，data和cur，也就是说每个下标都对应一个data和一个cur。data存放数据元素，cur存放后继在数组中的下标。这种用数组描述的链表叫做静态链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//若为0则是无指向</span></span><br><span class="line">&#125;Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通常数组的最后一个和第一个元素不存数据，把未被使用的数组元素成为备用链表，下标为0的元素的cur存放备用链表的第一个结点的下标，最后一个元素的cur存放第一个有数值的元素的下标</p>
<p><img src="https://pic.downk.cc/item/5f7d8ce31cd1bbb86b68baf0.png" alt="静态链表"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        space[i].cur = i+<span class="number">1</span>;<span class="comment">//space[0].cur为头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;<span class="comment">//静态链表为空，最后一个元素的cur为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h6><p>&emsp;&emsp;数组不存在像静态链表的结点申请和释放问题，所以需要自己实现两个函数。将所有未被使用过的及已经被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表取得第一个结点作为待插入新结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若备用空间链表非空，则返回分配的结点下标，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SLL</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">//当前数组第一个元素的cur值，也就是第一个备用空闲的下标。</span></span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur)</span><br><span class="line">    &#123;</span><br><span class="line">        space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">//拿走第一个结点，则下一个结点就是</span></span><br><span class="line">        							<span class="comment">//备用空闲的第一个结点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListInsert</span><span class="params">(StaticLinkList L; <span class="keyword">int</span> i; ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,l;</span><br><span class="line">    k = MAX_SIZE<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;ListLength(L) + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    j = Malloc_SSL(L);<span class="comment">//空闲的下标</span></span><br><span class="line">    <span class="keyword">if</span> (j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data = e;</span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i<span class="number">-1</span>; l++)<span class="comment">//第i个元素之前的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = L[k].cur;</span><br><span class="line">        &#125;</span><br><span class="line">        L[j].cur = L[k].cur;<span class="comment">//把第i个元素之前的cur赋值给新元素的cur</span></span><br><span class="line">        L[k].cur = j;<span class="comment">//把新元素的下标赋值给第i个元素之前的元素的cur</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h6><p>同样，删除元素时，需要释放结点，需要自己实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;<span class="comment">//把第一个元素cur值赋给要删除的分量</span></span><br><span class="line">    space[<span class="number">0</span>].cur = k;<span class="comment">//把要删除的分量下标赋值给第一个元素的cur</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除L中第i个数据元素e</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;ListLength(L))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = MAX_SIZE<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = L[k].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    j = L[k].cur;</span><br><span class="line">    L[k].cur = L[j].cur;</span><br><span class="line">    Free_SSL(L,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h6><ol>
<li>优点<ul>
<li>在插入和删除操作时，只需要修改游标，不需要移动元素，改进了顺序结构中插入和删除操作需要移动大量元素的缺点。</li>
</ul>
</li>
<li>缺点<ul>
<li>没有解决连续存储分配带来的表长难以确定的问题</li>
<li>失去了顺序存储结构随机存取的特性</li>
</ul>
</li>
</ol>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>&emsp;&emsp;将单链表中的终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表。</p>
<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p>&emsp;&emsp;双向链表是在单链表的每个结点中，在设置一个指向其前驱结点的指针域。</p>
<p><img src="https://pic.downk.cc/item/5f7d8ce31cd1bbb86b68bb00.png" alt="双向链表"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure>

<h6 id="插入s结点"><a href="#插入s结点" class="headerlink" title="插入s结点"></a>插入s结点</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>

<h6 id="删除p结点"><a href="#删除p结点" class="headerlink" title="删除p结点"></a>删除p结点</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本章各个概念关系图如下：</p>
<p><img src="https://pic.downk.cc/item/5f7d8dce1cd1bbb86b68fa4b.png" alt="关系图"></p>
<p><strong>注：以上内容参考《大话数据结构》，图片由Visio 2016绘画后截图而成。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-算法初识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/28/%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/"
    >算法初识</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/28/%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2020-09-28T13:34:46.000Z" itemprop="datePublished">2020-09-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<h5 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h5><p>输入、输出、有穷性、确定性和可行性。</p>
<ol>
<li>输入输出：算法应具有零个或者多个输入，至少有一个或者多个输出，可以是打印输出，也可以是返回一个或者多个值。</li>
<li>有穷性：是指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可以接受的时间内完成。</li>
<li>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。在一定条件下，算法只有一条执行路径，相同的输入只能有唯一的输出结果。</li>
<li>可行性：算法的每一步都必须是可行的，每一步都能够通过执行有限次数完成。</li>
</ol>
<h5 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h5><p>&emsp;&emsp;算法不是唯一的，同一个问题，可以有很多种解决问题的算法，但是相对好的算法还是存在的，好的算法具有以下特征：</p>
<ol>
<li><p>正确性</p>
<p>&emsp;&emsp;算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</p>
<ul>
<li>算法程序没有语法错误</li>
<li>算法程序对于合法的输入数据能够产生满足需求的输出结果</li>
<li>算法程序对于非法输入数据能够得出满足规格说明的结果</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果</li>
</ul>
</li>
<li><p>可读性</p>
<p>算法设计的另一目的就是为了便于阅读、理解和交流。可读性是算法好坏的重要标志。</p>
</li>
<li><p>健壮性</p>
<p>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或者莫名其妙的结果。</p>
</li>
<li><p>时间效率高和存储量低</p>
<p>时间效率指的是算法的执行时间，对于同一问题，执行时间短的算法效率高；存储量需求指的是算法在执行过程中需要的<strong>最大存储空间</strong>，主要之算法程序运行时所占用的内存或者外部硬盘存储空间。</p>
</li>
</ol>
<h5 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h5><ol>
<li><p>事后统计方法</p>
<p>&emsp;&emsp;这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。但是有以下缺陷：</p>
<ul>
<li>必须依据算法实现编制好程序，需要花费大量时间和精力。</li>
<li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。</li>
<li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前得不到体现。</li>
<li>等等</li>
</ul>
</li>
<li><p>事前分析估算方法</p>
<p>&emsp;&emsp;在计算机程序编制前，依据统计方法对算法进行估算。高级程序语言编写的程序在计算机运行时所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略、方法(根本)</li>
<li>编译产生的代码质量(软件)</li>
<li>问题的输入规模</li>
<li>机器执行指令的速度(硬件)</li>
</ul>
<p>例如：求1+2+3+…+100的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种算法</span></span><br><span class="line"><span class="keyword">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//执行n+1次</span></span><br><span class="line">&#123;</span><br><span class="line">    sum = sum + i;<span class="comment">//执行n次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种算法</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">//执行1次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);<span class="comment">//执行1次</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于同一个问题，第一种算法执行了2n+3次，而第二种算法执行了3次，忽略初始化变量和打印，其实就是n次和1次的差别，算法好坏显而易见。<br>分析算法时不计循环索引的递增和循环终止条件、变量声明、打印结果等操作，最终分析程序的运行时间时，最重要的是把程序堪称是独立于程序设计语言的算法或一些列步骤。<strong>重要的是把基本操作的数量与输入规模关联起来，基本操作的数量必须表示成输入规模的函数。</strong></p>
</li>
</ol>
<h5 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h5><p>&emsp;&emsp;给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。<br>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注<strong>主项(最高阶项)的阶数</strong>。</p>
<h5 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h5><p>&emsp;&emsp;<strong>定义：</strong>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间度量，记作：<strong><em>T(n)=O(f(n))</em></strong>。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度，其中f(n)是问题规模n的某个函数。<br>&emsp;&emsp;通常用大O法表示时间复杂度。一般情况下，随着n增大，T(n)增长最慢的算法为最优算法。O(1)叫常数阶、O(n)叫线性阶、O(n<sup>2</sup>)叫平方阶。</p>
<h6 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h6><ol>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数<br>得到的就是大O阶。</li>
</ol>
<h6 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h6><p>顺序结构的时间复杂度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的例子</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br></pre></td></tr></table></figure>

<p>这个算法的运行次数函数是f(n) = 3，第一步就是将常数项改为1，没有最高阶项，所以时间复杂度为O(1)。</p>
<h6 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h6><p>&emsp;&emsp;线性阶的循环结构，我们要确定某个算法的阶次，常常要确定某个特定语句或者某个语句集的执行次数，所以关键在与分析<strong>循环结构的运行情况</strong>。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环体中的代码要执行n次，它的循环的时间复杂度为O(n)。</p>
<h6 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环退出条件为count &gt;=n，那么有多少个2相乘后不小于n，则会退出循环。2<sup>x</sup> = n–&gt;x = log<sub>2</sub><sup>n</sup>，所以这个循环的时间复杂度为O(logn)。</p>
<h6 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;内层循环的循环体执行n次，时间复杂度为O(n)，外层循环体是内层循环，内层循环再执行n次，所以这段代码的时间复杂度为O(n<sup>2</sup>)。<strong>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</strong>。</p>
<h5 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h5><table>
<thead>
<tr>
<th>执行次数函数</th>
<th>阶</th>
<th>非正式术语</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>O(1)</td>
<td>常数阶</td>
</tr>
<tr>
<td>2n+3</td>
<td>O(n)</td>
<td>线性阶</td>
</tr>
<tr>
<td>3n<sup>2</sup>+2n+1</td>
<td>O(n<sup>2</sup>)</td>
<td>平方阶</td>
</tr>
<tr>
<td>2log<sub>2</sub><sup>n</sup>+20</td>
<td>O(logn)</td>
<td>对数阶</td>
</tr>
<tr>
<td>2n+3nlog<sub>2</sub><sup>n</sup>+19</td>
<td>O(nlogn)</td>
<td>nlogn阶</td>
</tr>
<tr>
<td>6n<sup>3</sup>+2n<sup>2</sup>+3n+4</td>
<td>O(n<sup>3</sup>)</td>
<td>立方阶</td>
</tr>
<tr>
<td>2<sup>n</sup></td>
<td>O(2<sup>n</sup>)</td>
<td>指数阶</td>
</tr>
</tbody></table>
<p>时间复杂度所消耗的时间从小到大依次：</p>
<p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(2<sup>n</sup>)</strong></p>
<h5 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h5><p>&emsp;&emsp;在应用中，<strong>除非特别指定，否则我们提到的运行时间都是最坏情况下的运行时间。</strong><br>&emsp;&emsp;平均运行时间是所有情况中，最有意义的，它是期望的运行时间。</p>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>&emsp;&emsp;算法的空间复杂度通过计算算法所需的存储空间实现，公式为：<strong>S(n) = O(f(n))，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</strong><br>&emsp;&emsp;一般情况，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占的空间只取决于问题本身和算法无关，只需要分析实现时所需大辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量是个常数。称此算法为原地工作，空间复杂度为O(1)。</p>
<p><strong>注：以上内容参考《大话数据结构》</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-数据结构初识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%9D%E8%AF%86/"
    >数据结构初识</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%9D%E8%AF%86/" class="article-date">
  <time datetime="2020-09-27T12:35:50.000Z" itemprop="datePublished">2020-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p>
<ul>
<li>数据结构：是相互之间存在一种或者多种特定关系的数据元素集合。</li>
<li>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合，包括数值、字符、声音、图像等等。数值等可以进行处理，而字符数据就需要进行非数值的处理，声音、图像、视频等也可以通过编码变成字符数据来处理。</li>
<li>数据元素：是组成数据的、有一定意义的<strong>基本单位</strong>，在计算机中通常作为整体处理，也称为记录。例如人类中的数据元素就是人。</li>
<li>数据项：一个数据元素可以有若干个数据项组成，比如人这样的数据元素可以有眼、鼻、嘴、耳、手、脚这些数据项，还可以有姓名、年龄、性别等数据项，具体有系统决定。是数据不可分割的<strong>最小单位</strong>，但是数据元素才是数据结构中建立数据模型的着眼点，例如我们会讨论一个电影角色，但不会单独研究他的姓名。</li>
<li>数据对象：是性质相同的数据元素的集合，是数据的子集。<strong>性质相同指的是数据元素具有相同数量和类型的数据项</strong>。数据对象时数据的子集，处理的数据元素通常具有相同性质，所以将数据对象简称数据。</li>
<li>数据类型：是指<strong>一组性质相同的值的集合以及定义在此集合上的一些操作的总称。</strong></li>
<li>抽象数据类型：ADT，指一个数学模型及定义在该模型上的一组操作。它的定义仅取决于一组逻辑特性，与其在计算机内部如何表示和实现无关。一个抽象数据类型定义了一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。</li>
</ul>
<p>关系图如下：</p>
<p><img src="https://pic.downk.cc/item/5f7088a7160a154a67c4c833.png" alt="关系图"></p>
<h4 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h4><ul>
<li><p>结构：不同数据之间不是相互独立的，而是存在特定的关系，这些关系称为结构。</p>
</li>
<li><p>逻辑结构：是指数据对象中数据元素之间的相互关系，针对的是具体问题。<strong>重点关注的问题。</strong></p>
<ol>
<li><p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系，各个数据元素是平等的。</p>
<p><img src="https://pic.downk.cc/item/5f7088a7160a154a67c4c835.png" alt="集合"></p>
</li>
<li><p>线性结构：线性结构中的数据元素之间是一对一的关系。</p>
<p><img src="https://pic.downk.cc/item/5f7088a7160a154a67c4c843.png" alt="线性"></p>
</li>
<li><p>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。</p>
<p><img src="https://pic.downk.cc/item/5f7088a7160a154a67c4c83a.png" alt="树形"></p>
</li>
<li><p>图形结构：图形结构的数据元素是多对多的关系。</p>
<p><img src="https://pic.downk.cc/item/5f7088a7160a154a67c4c83e.png" alt="图形"></p>
</li>
</ol>
<p>示意图表示数据的逻辑结构时：(1)将每一个数据元素看你做一个结点，圆圈表示。(2)元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，用带箭头的连线表示。</p>
</li>
<li><p>物理结构：也叫存储结构，<strong>是指数据的逻辑结构在计算机中的存储形式</strong>。数据的存储结构应正确反应数据元素之间的逻辑关系。数据是数据元素的集合，根据物理结构的定义，实际就是如何把数据元素存储到存储器，主要<strong>针对内存</strong>而言的，硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p>
<ol>
<li><p>顺序存储结构：把数据存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。例如数组。</p>
<p><img src="https://pic.downk.cc/item/5f708967160a154a67c5258a.png" alt="顺序"></p>
</li>
<li><p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，需要有一个指针存放数据元素的地址，通过地址就可以找到相关联的数据元素的位置。</p>
<p><img src="https://pic.downk.cc/item/5f708967160a154a67c52588.png" alt="链式"></p>
</li>
</ol>
<p>逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储到计算机的内存中。</p>
</li>
</ul>
<p><strong>注：参考《大话数据结构》，文中图使用Visio 2016绘画后截图。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-C-C-编译过程学习记录"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/16/C-C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"
    >C/C++编译过程学习记录</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/16/C-C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-08-16T15:12:58.000Z" itemprop="datePublished">2020-08-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>&emsp;&emsp;说来惭愧，我是一个二本院校的软件工程专业毕业的学生，到现在仿佛什么都还不会。对于大一下学期学的C语言，基础东西还有很多都不会，有些东西也许之前学过，但是我都忘记了。今天忽然看到桌子上的《C Primer Plus》，就拿起来翻了一会儿。翻了十多页，发现整天说的<strong>编译-链接-运行</strong>，我并不太清楚它这个过程做了什么，只知道编译成机器语言生成目标文件，再链接成可执行文件，反正每次写完源代码后就是一通点击。就去查一下吧。</p>
</blockquote>
<h5 id="1-编译型和解释型"><a href="#1-编译型和解释型" class="headerlink" title="1.编译型和解释型"></a>1.编译型和解释型</h5><blockquote>
<p>&emsp;&emsp;C语言和C++都是编译型语言，相对于解释型语言来说的。<strong>编译型</strong>的程序在执行之前需要一个专门的编译过程，把源代码编译成机器语言，之后再运行的时候就不用重新编译了。<strong>解释型</strong>的程序不需要在运行前进行编译，在运行时才会进行翻译成机器语言，看似少了一个编译的过程，但是以后每次执行一次就要翻译一次。</p>
</blockquote>
<h5 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2.编译过程"></a>2.编译过程</h5><blockquote>
<p>&emsp;&emsp;最近刚装了Linux的虚拟机（Manjaro），以Linux常用的gcc编译器来说，gcc的编译过程其实是分为四个过程：<strong>预处理、编译、汇编、链接</strong>。过程如下：<br>[图片上传失败…(image-8b2b7e-1585469291477)]<br><strong>1.预处理</strong><br>&emsp;&emsp;这一步主要就是处理一些#开头的，对文件中的include的文件插入原文件，对于宏定义define这些进行分析，生成.i为后缀的文件。所以我们经常在编译时出错，就要考虑头文件是否有问题。<br>命令：<code>gcc -E Hello.c -o Hello.i</code><br><strong>2.编译</strong><br>&emsp;&emsp;此时，编译将C/C++代码（也就是预处理后的.i文件）转换成汇编代码，生成以.s为后缀的文件。<br>命令：<code>gcc -S Hello.i -o Hello.s</code><br><strong>3.汇编</strong><br>&emsp;&emsp;汇编就是将上一步生成的汇编代码转换成机器代码。不只我们看C语言跟看”天书”一样，直接让计算机看C语言代码，它也不懂🤣。将生成以.o为后缀的目标文件(Windows下是.obj文件)。<br>命令：<code>gcc -c Hello.s -o Hello.o</code><br><strong>4.链接</strong><br>&emsp;&emsp;链接就是将各个模块的相互引用正确地连接起来，最终生成可执行文件。链接又分为动态链接和静态链接，库也分为静库（Linux下的.a,Windows.lib）和动态库（Linux下的.so,Windows下的.dll）</p>
<ul>
<li>静态链接<br>&emsp;&emsp;在连接阶段，将源文件中用到的库函数和汇编阶段生成的.o目标文件合并生成可执行文件。也就是引用到的函数库成为可执行文件的一部分。多个运行程序用到某个库函数的时候，内存将会有多个库函数的拷贝。这必定会增加可执行文件占用的空间，并且在库文件要升级的话就要重新编译。但是增加了可移植性，可执行文件放在别的环境就不用考虑库函数的问题了。</li>
<li>动态链接<br>&emsp;&emsp;动态链接不再将库函数直接加入可执行文件。只是在其中加入了所调用函数的描述信息（通常是重定位信息）。在可执行文件执行时，才会去链接所需库函数。这样可执行文件占用空间较小，并且内存中也只有一个所用库的拷贝。但是当改变运行环境，很有可能找不到函数库。<br>&emsp;&emsp;程序的时间空间复杂度是趋于平衡的，静态链接后可执行文件占用空间更大，运行时间更短。动态链接每次运行都要重新加载函数库，运行时间更长，但是占用空间更小。</li>
</ul>
</blockquote>
<h5 id="3-gcc常用命令"><a href="#3-gcc常用命令" class="headerlink" title="3.gcc常用命令"></a>3.gcc常用命令</h5><blockquote>
<p><code>gcc [选项] [文件]</code><br>选项：</p>
<ul>
<li><strong>-E:</strong> 预处理，不进行编译、汇编、链接</li>
<li><strong>-S:</strong> 编译生成汇编语言</li>
<li><strong>-c:</strong> 汇编生成可执行文件</li>
<li><strong>-o:</strong> 指定输出文件名</li>
<li><strong>-static:</strong> 对生成文件采用静态链接</li>
<li><strong>-share:</strong> 使用动态链接</li>
</ul>
</blockquote>
<h5 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h5><h6 id="1-Linux下的结果"><a href="#1-Linux下的结果" class="headerlink" title="1.Linux下的结果"></a>1.Linux下的结果</h6><p><img src="https://pic.downk.cc/item/5f39538b14195aa59465df1d.png" alt="Linux下的编译结果"></p>
<h6 id="2-Windows10下的结果"><a href="#2-Windows10下的结果" class="headerlink" title="2.Windows10下的结果"></a>2.Windows10下的结果</h6><p><img src="https://pic.downk.cc/item/5f39534b14195aa59465c990.png" alt="Win10下的编译结果"></p>
<h5 id="5-结语"><a href="#5-结语" class="headerlink" title="5.结语"></a>5.结语</h5><blockquote>
<p>&emsp;&emsp;虽然看似清楚了，其实平时写小的程序都不会这么一步步来，通常都是这样：<br>&emsp;&emsp;<code>gcc file.c -o file</code>就直接就产生了可执行文件。<br>&emsp;&emsp;<code>gcc file.c</code>也可以，没有给定文件输出名，Linux下默认产生的就<strong>a.out</strong>文件，而在Windows也同样只是产生<strong>a.exe</strong>文件，就是默认的文件名。<br>&emsp;&emsp;如果分开进行比较容易知道具体哪一步出错，可以相应的找出错误，一步到位如果出错比较难找。</p>
</blockquote>
<p><strong><em>注：  以上都是个人看法，也许有错的地方，烦请指出，谢谢！</em></strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C/C++</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-流媒体技术测试可用的rtmp、hls地址"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E6%B5%8B%E8%AF%95%E5%8F%AF%E7%94%A8%E7%9A%84rtmp%E3%80%81hls%E5%9C%B0%E5%9D%80/"
    >流媒体技术测试可用的rtmp、hls地址</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/09/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF%E6%B5%8B%E8%AF%95%E5%8F%AF%E7%94%A8%E7%9A%84rtmp%E3%80%81hls%E5%9C%B0%E5%9D%80/" class="article-date">
  <time datetime="2020-07-09T15:07:03.000Z" itemprop="datePublished">2020-07-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/">流媒体技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&emsp;&emsp;最近在做流媒体服务器，让人苦恼的是网上很难找到测试地址，虽然说可以自己进行推流，但是在做客户端的时候，每次都要自己推流，有些麻烦。最终，还是找到了大神的分享，在此记录一下。</p>
<h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4><p>下边是我自己用过的直播流：</p>
<p>参数：1080p  25fps  yuv420p  h.264  aac 1999kbps  </p>
<p>rtmp://58.200.131.2:1935/livetv/cctv1hd 综合<br>rtmp://58.200.131.2:1935/livetv/cctv2hd 财经<br>rtmp://58.200.131.2:1935/livetv/cctv6hd 电影<br>rtmp://58.200.131.2:1935/livetv/cctv5hd 体育<br>rtmp://58.200.131.2:1935/livetv/cctv7hd 军事<br>rtmp://58.200.131.2:1935/livetv/gfjstv 国防军事 </p>
<h4 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h4><p>参数：1080p  25fps  yuv420p  h.264  aac </p>
<p><a href="http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8</a><br><a href="http://ivi.bupt.edu.cn/hls/cctv3hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv3hd.m3u8</a><br><a href="http://ivi.bupt.edu.cn/hls/cctv5hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv5hd.m3u8</a><br><a href="http://ivi.bupt.edu.cn/hls/cctv5phd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv5phd.m3u8</a><br><a href="http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8</a><br><a href="http://ivi.bupt.edu.cn/hls/cctv7hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv7hd.m3u8</a></p>
<h4 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h4><p>参数：240x160  24fps  yuv420p  aac  h.264</p>
<p>这个比较难找，而且分辨率低。</p>
<p>rtsp://wowzaec2demo.streamlock.net/vod/mp4:BigBuckBunny_115k.mov</p>
<p>还有其他的电视直播地址可以参考这位大神的博客<a href="https://www.cnblogs.com/juanxincai/p/12900303.html" target="_blank" rel="noopener">卷心菜的奇妙历险</a>，各大卫视都有。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hls/" rel="tag">hls</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtmp/" rel="tag">rtmp</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-个人介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/02/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"
    >个人介绍</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/02/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2020-07-02T00:34:19.000Z" itemprop="datePublished">2020-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h4><p><strong>姓名：</strong>司志超</p>
<p><strong>英文名：</strong>Clay</p>
<p><strong>生日：</strong>1996-10-13</p>
<p><strong>家乡：</strong>河南-郑州</p>
<p><strong>现居地：</strong>重庆</p>
<h4 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h4><p><strong>本科：</strong>天津商业大学-软件工程</p>
<p><strong>硕士在读：</strong>重庆邮电大学-计算机技术</p>
<p><strong>研究方向：</strong>数字图像处理-图像拼接</p>
<h4 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h4><p>&emsp;&emsp;虽然我是一个工科男，但是并不影响我有优雅文艺的爱好，阅读、听音乐这两个项目几乎占据我所有的闲暇时间，书籍和音乐种类不限。我虽然不是很喜欢运动，但是我喜欢看球赛，我是曼联和拜仁的球迷，有时候会熬夜看球赛，不过大多数是看回放，毕竟第二天还要正常做事。如果非要说有什么体育运动爱好，不知道桌球算不算🙄。</p>
<h4 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h4><p>&emsp;&emsp;我是一名九零后，上大学是我第一次从小县城走出来，去到天津上大学。我很庆幸当初做出这个决定，四年下来，不仅是知识、技能的提升，还拓宽了视野，改变了我的世界观以及思维方式，我觉得这是最重要的。现在又从天津考研来到了重庆，甚至毕业之后我也没有回家乡工作的打算，不是我不想家，而是家乡的就业形势相对于我的专业来说，没那么友好，毕竟全国互联网行业发展较好的，只有那么几个城市。</p>
<p>&emsp;&emsp;我自己是一个比较喜欢沉浸在自己世界里的人，除非是我自己有心事，否则无论周围环境如何，我都可以很安静，这可能跟我准备考研的时候，每天听音乐十小时以上有关，不管多么劲爆的音乐，我都可以写数学题，甚至节奏感强的音乐还能加快我的思考和书写速度。无论我是否听音乐或者听书，多数时间，我都会带着耳机，这仿佛已经成为我进入状态的一个仪式。我还是一个比较细心且敏感的人，这让我多少有些烦恼，因为经常注意到一些细节，它会影响到我的心情。</p>
<p>&emsp;&emsp;虽然我是一名计算机在读研一硕士，但是我的技术功底相当于小白。因为我并不是很喜欢研究这些东西，整天有些不务正业，去了解各个领域，包括金融、哲学、历史等等，我不太像一个工科生。偶然看到一位大神的视频，我觉得专业还是得去深入学习，希望这个博客能够见证我的成长！</p>
<h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p><strong>EMail：</strong><a href="mailto:clay_si@126.com">clay_si@126.com</a></p>
<p><strong>QQ：</strong>305397510</p>
<p><strong>微信：</strong></p>
<img src="https://i.loli.net/2020/07/02/1XGrfZjv3h9z2PN.jpg" alt="wechat.jpg" style="zoom:50%;" />

<p>如果对我写的文章有兴趣，或者觉得有错误，欢迎加好友或者发邮件交流哦。</p>
<h4 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h4><p>&emsp;&emsp;其实很早就想有一个自己的博客，记录一下自己的生活以及技术上踩过的坑，以前也在CSDN写过几篇文章，但是我觉得它专业性太强，都是一些技术博客，不太适合写一些别的领域或者和生活相关的话题，所以我就搭建了自己博客。该博客将会涉及的比较广，包括(图像、Java、C++、股市、阅读、音乐、生活情感等)多数是为了记录生活，以后回看，还能想起点什么，所以多少会有一些错误的地方，希望看到的朋友见谅，欢迎交流哦，谢谢！</p>
<p>&emsp;&emsp;这是一个采用Hexo框架搭建的静态博客，我将它部署在<a href="https://github.com/Clay-Si/Clay-Si.github.io.git" target="_blank" rel="noopener">我的github</a>上了，主题采用的是<a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank" rel="noopener">Ayer</a>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E4%BA%8E%E6%88%91/" rel="tag">关于我</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-First-Article"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/01/First-Article/"
    >First Article</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/01/First-Article/" class="article-date">
  <time datetime="2020-07-01T02:47:22.000Z" itemprop="datePublished">2020-07-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="第一次搭建博客，感谢Hexo"><a href="#第一次搭建博客，感谢Hexo" class="headerlink" title="第一次搭建博客，感谢Hexo"></a>第一次搭建博客，感谢Hexo</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/01/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/01/hello-world/" class="article-date">
  <time datetime="2020-07-01T02:41:31.374Z" itemprop="datePublished">2020-07-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> Clay
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Clay&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://pic.downk.cc/item/5efd441a14195aa594629b5f.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://pic.downk.cc/item/5efd444414195aa59462af71.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>